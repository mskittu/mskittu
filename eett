import os
import socket
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders

# Set the base paths for files
base_path = os.getenv("FILE_PATH", "/default/path")
oracle_query_file = os.path.join(base_path, "query_file.txt")
compare_csv_file = os.path.join(base_path, "compare.csv")

# Email configuration function
def environmentval():
    # Get the first 4 characters of the hostname
    edgenode_env = socket.gethostname()[:4]
    print("edgenode_env is", edgenode_env)
    
    # Define mappings for known environments
    environment_mappings = {
        "dcds": ("DEV", "dcds", "UAT87@mo-collab.barclayscorp.com"), 
        "qcds": ("QA", "qcds", "UAT87@mo-collab.barclayscorp.com"),
        "pcds": ("PROD", "pcds", "IDTeamImpairment@barclays.com, USCDSRTBTEAM@barclays.com"),
    }

    # Check if the environment is recognized
    if edgenode_env in environment_mappings: 
        upper_edgenode_env, dbase, mailto = environment_mappings[edgenode_env]
    else:
        # Default handling for unknown environments
        print(f"Warning: Unknown environment '{edgenode_env}', using default values.")
        upper_edgenode_env, dbase, mailto = "DEFAULT_ENV", "default_db", "default_email@example.com"

    # Export environment variables
    os.environ["UPPER_EDGENODE_ENV"] = upper_edgenode_env
    os.environ["DBASE"] = dbase
    os.environ["MAILTO"] = mailto
    
    print(f"Environment: {upper_edgenode_env}")
    print(f"Database: {dbase}")
    print(f"Mail To: {mailto}")
    return mailto

# Function to send an email with an attachment
def send_email_with_attachment(subject, body, attachment_path, recipients):
    try:
        # Email sender configuration
        sender_email = "noreply-fin-notification@barclaycardus.com"
        smtp_server = "smtp-relay-uat.barclays.intranet"
        smtp_port = 25
        
        # Create the email
        message = MIMEMultipart()
        message["From"] = sender_email
        message["To"] = recipients
        message["Subject"] = subject
        
        # Add the email body
        message.attach(MIMEText(body, "plain"))
        
        # Attach the CSV file
        with open(attachment_path, "rb") as attachment:
            part = MIMEBase("application", "octet-stream")
            part.set_payload(attachment.read())
        encoders.encode_base64(part)
        part.add_header("Content-Disposition", f"attachment; filename={os.path.basename(attachment_path)}")
        message.attach(part)
        
        # Send the email
        with smtplib.SMTP(smtp_server, smtp_port) as server:
            server.sendmail(sender_email, recipients.split(","), message.as_string())
        print(f"Email sent successfully to {recipients}")
    
    except Exception as e:
        print(f"Error sending email: {e}")

# Main execution logic
if __name__ == "__main__":
    try:
        # Retrieve the email recipient based on the environment
        mailto = environmentval()
        
        # Placeholder for Oracle and Hive table count retrieval and comparison
        # oracle_counts = get_oracle_table_counts_from_file(oracle_query_file)
        # hive_counts = get_hive_table_count()
        
        # Compare counts and log the results (Placeholder function calls)
        # if oracle_counts and hive_counts:
        #     compare_counts(oracle_counts, hive_counts)
        
        # Send the results via email
        subject = "Oracle and Hive Table Count Comparison Results"
        body = "Please find attached the comparison results between Oracle and Hive table counts."
        send_email_with_attachment(subject, body, compare_csv_file, mailto)
    
    except Exception as e:
        print(f"Error during execution: {e}")
